esphome:
  name: epaper-panel
  friendly_name: ePaper Panel
  on_boot:
    priority: -100
    then:
      - component.update: battery_voltage_raw
      - delay: 200ms
      - component.update: battery_voltage
      - component.update: battery_level
      - wait_until:
          condition:
            lambda: |-
              return id(family_room_co2).has_state() &&
                     id(family_room_aqi).has_state() &&
                     id(outdoor_aqi).has_state();
          timeout: 90s
      - script.execute: schedule_refresh

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "5i4azvXNTvFw31YkZK22aQnOsbzA51b5+PvZBq8T9M8="

ota:
  - platform: esphome
    password: "84622fc91e2dce7290ce38cc33e68251"

deep_sleep:
  id: deep_sleep_ctrl
  sleep_duration: 10min

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Epaper-Panel Fallback Hotspot"
    password: "OZrb7lk6llkP"

captive_portal:

time:
  - platform: homeassistant
    id: homeassistant_time

globals:
  - id: last_update_epoch
    type: int
    restore_value: no
    initial_value: '0'

font:
  - file: "gfonts://Roboto"
    id: font_large
    size: 48
  - file: "gfonts://Roboto"
    id: font_medium
    size: 32
  - file: "gfonts://Roboto"
    id: font_small
    size: 24

sensor:
  - platform: homeassistant
    entity_id: sensor.aranet_family_room_carbon_dioxide
    id: family_room_co2
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: adc
    pin: GPIO0
    id: battery_voltage_raw
    internal: true
    attenuation: 11db
    update_interval: never
    filters:
      # The onboard voltage divider scales the pack voltage down for the ADC.
      # Adjust this multiplier if your hardware uses a different ratio. The
      # stock driver board divides the voltage roughly by four, so compensate
      # for that here.
      - multiply: 4.0
  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    state_class: measurement
    device_class: voltage
    accuracy_decimals: 2
    update_interval: never
    lambda: |-
      if (!id(battery_voltage_raw).has_state()) {
        return {};  // No reading available yet.
      }
      return id(battery_voltage_raw).state;
  - platform: template
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      if (!id(battery_voltage).has_state()) {
        return NAN;
      }
      const float min_voltage = 3.3f;
      const float max_voltage = 4.2f;
      float percent = (id(battery_voltage).state - min_voltage) /
                      (max_voltage - min_voltage) * 100.0f;
      if (percent < 0.0f) {
        return 0.0f;
      }
      if (percent > 100.0f) {
        return 100.0f;
      }
      return percent;
  - platform: homeassistant
    entity_id: sensor.family_room_air_quality_index_epa
    id: family_room_aqi
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: sensor.purple_air_outside_air_quality_index_epa
    id: outdoor_aqi
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: sensor.pool_thermometer_temperature
    id: pool_temperature
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: sensor.spa_thermometer_temperature
    id: spa_temperature
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: weather.tomorrow_io_nowcast
    attribute: temperature
    id: nowcast_temperature
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: weather.tomorrow_io_nowcast
    attribute: humidity
    id: nowcast_humidity
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: weather.tomorrow_io_nowcast
    attribute: wind_speed
    id: nowcast_wind_speed
    on_value:
      then:
        - script.execute: schedule_refresh
  - platform: homeassistant
    entity_id: weather.tomorrow_io_nowcast
    attribute: precipitation_probability
    id: nowcast_precipitation_probability
    on_value:
      then:
        - script.execute: schedule_refresh

text_sensor:
  - platform: homeassistant
    entity_id: weather.tomorrow_io_nowcast
    id: nowcast_summary
    on_value:
      then:
        - script.execute: schedule_refresh

script:
  - id: schedule_refresh
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return id(refresh_display_and_sleep).is_running();
          then:
            - logger.log:
                format: "Refresh already in progress; skipping new schedule"
                level: DEBUG
          else:
            - delay: 5s
            - script.execute: refresh_display_and_sleep
  - id: refresh_display_and_sleep
    mode: restart
    then:
      - component.update: battery_voltage_raw
      - delay: 200ms
      - component.update: battery_voltage
      - component.update: battery_level
      - if:
          condition:
            lambda: |-
              return id(family_room_co2).has_state() &&
                     id(family_room_aqi).has_state() &&
                     id(outdoor_aqi).has_state();
          then:
            - lambda: |-
                if (id(homeassistant_time).now().is_valid()) {
                  id(last_update_epoch) = id(homeassistant_time).now().timestamp;
                }
            - component.update: main_display
            - delay: 15s
            - deep_sleep.enter: deep_sleep_ctrl
          else:
            - logger.log:
                format: "Waiting for sensor data before refreshing display"
                level: INFO
            - delay: 1s
            - script.execute: refresh_display_and_sleep

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    id: main_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: never
    lambda: |-
      it.fill(esphome::display::COLOR_OFF);

      const int SCREEN_WIDTH = 800;
      const int MARGIN = 20;
      const int COLUMN_GAP = 40;
      const int COLUMN_WIDTH = (SCREEN_WIDTH - (2 * MARGIN) - COLUMN_GAP) / 2;
      const int LEFT_COLUMN_X = MARGIN;
      const int RIGHT_COLUMN_X = LEFT_COLUMN_X + COLUMN_WIDTH + COLUMN_GAP;
      const int HEADER_BOTTOM = MARGIN + 40;
      const int CONTENT_TOP = HEADER_BOTTOM + 20;

      it.printf(LEFT_COLUMN_X, MARGIN, id(font_medium), "Family Room Air Quality");
      it.horizontal_line(MARGIN, HEADER_BOTTOM, SCREEN_WIDTH - (2 * MARGIN));

      auto draw_sensor_row = [&](int row_y, const char *label, float value, const char *unit) -> int {
        it.printf(LEFT_COLUMN_X, row_y, id(font_small), "%s", label);
        const int value_anchor_x = LEFT_COLUMN_X + COLUMN_WIDTH;
        const int value_offset_y = row_y - 6;
        if (!isnan(value)) {
          if (unit != nullptr && unit[0] != '\0') {
            it.printf(value_anchor_x, value_offset_y, id(font_large), esphome::display::TextAlign::TOP_RIGHT, "%.0f %s", value, unit);
          } else {
            it.printf(value_anchor_x, value_offset_y, id(font_large), esphome::display::TextAlign::TOP_RIGHT, "%.0f", value);
          }
        } else {
          it.printf(value_anchor_x, value_offset_y, id(font_large), esphome::display::TextAlign::TOP_RIGHT, "--");
        }
        return row_y + 64;
      };

      auto render_wrapped_text = [&](int x, int base_y, const std::string &text, esphome::font::Font *font, int max_width) -> int {
        int y_cursor = base_y;
        auto print_line = [&](const std::string &line) {
          int x1, y1, w, h;
          it.get_text_bounds(x, y_cursor, line.c_str(), font, esphome::display::TextAlign::TOP_LEFT, &x1, &y1, &w, &h);
          it.printf(x, y_cursor, font, "%s", line.c_str());
          y_cursor += h + 6;
        };

        std::string current_line;
        size_t position = 0;
        while (position < text.size()) {
          while (position < text.size() && text[position] == ' ') {
            position++;
          }
          if (position >= text.size()) {
            break;
          }

          size_t next_space = text.find(' ', position);
          std::string word = text.substr(position, next_space == std::string::npos ? text.size() - position : next_space - position);
          std::string candidate = current_line.empty() ? word : current_line + " " + word;

          int x1, y1, w, h;
          it.get_text_bounds(x, y_cursor, candidate.c_str(), font, esphome::display::TextAlign::TOP_LEFT, &x1, &y1, &w, &h);
          if (!current_line.empty() && w > max_width) {
            print_line(current_line);
            current_line = word;
          } else {
            current_line = candidate;
          }

          if (next_space == std::string::npos) {
            break;
          }
          position = next_space + 1;
        }

        if (!current_line.empty()) {
          print_line(current_line);
        }

        return y_cursor;
      };

      auto draw_weather_line = [&](int x, int y, const std::string &text) -> int {
        int x1, y1, w, h;
        it.get_text_bounds(x, y, text.c_str(), id(font_small), esphome::display::TextAlign::TOP_LEFT, &x1, &y1, &w, &h);
        it.printf(x, y, id(font_small), "%s", text.c_str());
        return y + h + 6;
      };

      int sensor_y = CONTENT_TOP;
      sensor_y = draw_sensor_row(sensor_y, "CO₂", id(family_room_co2).state, "ppm");
      sensor_y = draw_sensor_row(sensor_y, "Family AQI", id(family_room_aqi).state, "");
      sensor_y = draw_sensor_row(sensor_y, "Outdoor AQI", id(outdoor_aqi).state, "");
      sensor_y = draw_sensor_row(sensor_y, "Pool", id(pool_temperature).state, "°");
      sensor_y = draw_sensor_row(sensor_y, "Spa", id(spa_temperature).state, "°");
      sensor_y = draw_sensor_row(sensor_y, "Battery", id(battery_level).state, "%");

      int weather_y = CONTENT_TOP;
      if (id(nowcast_summary).has_state() && !id(nowcast_summary).state.empty()) {
        weather_y = render_wrapped_text(RIGHT_COLUMN_X, weather_y, id(nowcast_summary).state, id(font_medium), COLUMN_WIDTH);
      } else {
        weather_y = render_wrapped_text(RIGHT_COLUMN_X, weather_y, "Weather data unavailable", id(font_medium), COLUMN_WIDTH);
      }

      if (!isnan(id(nowcast_temperature).state)) {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, esphome::str_sprintf("Temperature: %.1f°", id(nowcast_temperature).state));
      } else {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, "Temperature: --°");
      }

      if (!isnan(id(nowcast_humidity).state)) {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, esphome::str_sprintf("Humidity: %.0f%%", id(nowcast_humidity).state));
      } else {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, "Humidity: --%%");
      }

      if (!isnan(id(nowcast_wind_speed).state)) {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, esphome::str_sprintf("Wind: %.1f", id(nowcast_wind_speed).state));
      } else {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, "Wind: --");
      }

      if (!isnan(id(nowcast_precipitation_probability).state)) {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, esphome::str_sprintf("Precipitation Chance: %.0f%%", id(nowcast_precipitation_probability).state));
      } else {
        weather_y = draw_weather_line(RIGHT_COLUMN_X, weather_y, "Precipitation Chance: --%%");
      }

      if (id(last_update_epoch) > 0) {
        auto last_update = esphome::ESPTime::from_epoch_local(id(last_update_epoch));
        if (last_update.is_valid()) {
          char buffer[40];
          last_update.strftime(buffer, sizeof(buffer), "%a %d %b %H:%M");
          it.printf(SCREEN_WIDTH - MARGIN, MARGIN, id(font_small), esphome::display::TextAlign::TOP_RIGHT, "Last updated %s", buffer);
        } else {
          it.printf(SCREEN_WIDTH - MARGIN, MARGIN, id(font_small), esphome::display::TextAlign::TOP_RIGHT, "Last updated --");
        }
      } else {
        it.printf(SCREEN_WIDTH - MARGIN, MARGIN, id(font_small), esphome::display::TextAlign::TOP_RIGHT, "Last updated --");
      }
